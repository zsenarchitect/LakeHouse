{"version":3,"file":"core-nodejs.js","sources":["../../src/utils/require-uncached.ts","../../src/htmlvalidate.nodejs.ts","../../src/config/resolver/nodejs/determine-root-dir.ts","../../src/config/resolver/nodejs/expand-relative-path.ts","../../src/config/resolver/nodejs/cjs-resolver.ts","../../src/config/resolver/nodejs/import-function.ts","../../src/config/resolver/nodejs/internal-import.ts","../../src/config/resolver/nodejs/esm-resolver.ts","../../src/config/loaders/file-system.ts","../../src/utils/compatibility-check.nodejs.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-deprecated -- works for now and this will be removed when commonjs support ends */\n\n/**\n * Similar to `require(..)` but removes the cached copy first.\n */\nexport function requireUncached(require: NodeJS.Require, moduleId: string): unknown {\n\tconst filename = require.resolve(moduleId);\n\n\t/* remove references from the parent module to prevent memory leak */\n\tconst m = require.cache[filename];\n\tif (m?.parent) {\n\t\tconst { parent } = m;\n\t\tfor (let i = parent.children.length - 1; i >= 0; i--) {\n\t\t\tif (parent.children[i].id === filename) {\n\t\t\t\tparent.children.splice(i, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* remove old module from cache */\n\t/* eslint-disable-next-line @typescript-eslint/no-dynamic-delete -- needed to perform its function */\n\tdelete require.cache[filename];\n\n\t/* eslint-disable-next-line import/no-dynamic-require, security/detect-non-literal-require -- as expected but should be moved to upcoming resolver class */\n\treturn require(filename);\n}\n","import fs from \"node:fs\";\nimport { type SchemaObject } from \"ajv\";\nimport { type ConfigData, type ResolvedConfig, ConfigLoader } from \"./config\";\nimport { normalizeSource, type Source } from \"./context\";\nimport { type SourceHooks } from \"./context/source\";\nimport { type EventDump, type TokenDump, Engine } from \"./engine\";\nimport { type Message } from \"./message\";\nimport { Parser } from \"./parser\";\nimport { type Report, Reporter } from \"./reporter\";\nimport { type RuleDocumentation } from \"./rule\";\nimport configurationSchema from \"./schema/config.json\";\nimport { StaticConfigLoader } from \"./config/loaders/static\";\nimport { isThenable } from \"./utils\";\nimport { UserError } from \"./error\";\nimport {\n\ttype TransformFS,\n\ttransformFilename,\n\ttransformFilenameSync,\n\ttransformSource,\n\ttransformSourceSync,\n} from \"./transform\";\n\nconst defaultFS: TransformFS = {\n\treadFileSync: fs.readFileSync,\n};\n\nfunction isSourceHooks(value: any): value is SourceHooks {\n\tif (!value || typeof value === \"string\") {\n\t\treturn false;\n\t}\n\treturn Boolean(value.processAttribute ?? value.processElement);\n}\n\nfunction isConfigData(value: any): value is ConfigData {\n\tif (!value || typeof value === \"string\") {\n\t\treturn false;\n\t}\n\treturn !(value.processAttribute ?? value.processElement);\n}\n\n/**\n * Primary API for using HTML-validate.\n *\n * Provides high-level abstractions for common operations.\n *\n * @public\n */\nexport class HtmlValidate {\n\tprotected configLoader: ConfigLoader;\n\n\t/**\n\t * Create a new validator.\n\t *\n\t * @public\n\t * @param configLoader - Use a custom configuration loader.\n\t * @param config - If set it provides the global default configuration. By\n\t * default `Config.defaultConfig()` is used.\n\t */\n\tpublic constructor(config?: ConfigData);\n\tpublic constructor(configLoader: ConfigLoader);\n\tpublic constructor(arg?: ConfigLoader | ConfigData) {\n\t\tconst [loader, config] = arg instanceof ConfigLoader ? [arg, undefined] : [undefined, arg];\n\t\tthis.configLoader = loader ?? new StaticConfigLoader(config);\n\t}\n\n\t/**\n\t * Parse and validate HTML from string.\n\t *\n\t * @public\n\t * @param str - Text to parse.\n\t * @param filename - If set configuration is loaded for given filename.\n\t * @param hooks - Optional hooks (see [[Source]]) for definition.\n\t * @returns Report output.\n\t */\n\t/* eslint-disable @typescript-eslint/unified-signatures -- for easier readability */\n\tpublic validateString(str: string): Promise<Report>;\n\tpublic validateString(str: string, filename: string): Promise<Report>;\n\tpublic validateString(str: string, hooks: SourceHooks): Promise<Report>;\n\tpublic validateString(str: string, options: ConfigData): Promise<Report>;\n\tpublic validateString(str: string, filename: string, hooks: SourceHooks): Promise<Report>;\n\tpublic validateString(str: string, filename: string, options: ConfigData): Promise<Report>;\n\tpublic validateString(\n\t\tstr: string,\n\t\tfilename: string,\n\t\toptions: ConfigData,\n\t\thooks: SourceHooks,\n\t): Promise<Report>;\n\t/* eslint-enable @typescript-eslint/unified-signatures */\n\tpublic validateString(\n\t\tstr: string,\n\t\targ1?: string | SourceHooks | ConfigData,\n\t\targ2?: SourceHooks | ConfigData,\n\t\targ3?: SourceHooks,\n\t): Promise<Report> {\n\t\tconst filename = typeof arg1 === \"string\" ? arg1 : \"inline\";\n\t\tconst options = isConfigData(arg1) ? arg1 : isConfigData(arg2) ? arg2 : undefined; // eslint-disable-line sonarjs/no-nested-conditional -- easier to read than the alternative */\n\t\tconst hooks = isSourceHooks(arg1) ? arg1 : isSourceHooks(arg2) ? arg2 : arg3; // eslint-disable-line sonarjs/no-nested-conditional -- easier to read than the alternative */\n\t\tconst source = {\n\t\t\tdata: str,\n\t\t\tfilename,\n\t\t\tline: 1,\n\t\t\tcolumn: 1,\n\t\t\toffset: 0,\n\t\t\thooks,\n\t\t};\n\t\treturn this.validateSource(source, options);\n\t}\n\n\t/**\n\t * Parse and validate HTML from string.\n\t *\n\t * @public\n\t * @param str - Text to parse.\n\t * @param filename - If set configuration is loaded for given filename.\n\t * @param hooks - Optional hooks (see [[Source]]) for definition.\n\t * @returns Report output.\n\t */\n\t/* eslint-disable @typescript-eslint/unified-signatures -- for easier readability */\n\tpublic validateStringSync(str: string): Report;\n\tpublic validateStringSync(str: string, filename: string): Report;\n\tpublic validateStringSync(str: string, hooks: SourceHooks): Report;\n\tpublic validateStringSync(str: string, options: ConfigData): Report;\n\tpublic validateStringSync(str: string, filename: string, hooks: SourceHooks): Report;\n\tpublic validateStringSync(str: string, filename: string, options: ConfigData): Report;\n\tpublic validateStringSync(\n\t\tstr: string,\n\t\tfilename: string,\n\t\toptions: ConfigData,\n\t\thooks: SourceHooks,\n\t): Report;\n\t/* eslint-enable @typescript-eslint/unified-signatures */\n\tpublic validateStringSync(\n\t\tstr: string,\n\t\targ1?: string | SourceHooks | ConfigData,\n\t\targ2?: SourceHooks | ConfigData,\n\t\targ3?: SourceHooks,\n\t): Report {\n\t\tconst filename = typeof arg1 === \"string\" ? arg1 : \"inline\";\n\t\tconst options = isConfigData(arg1) ? arg1 : isConfigData(arg2) ? arg2 : undefined; // eslint-disable-line sonarjs/no-nested-conditional -- easier to read than the alternative */\n\t\tconst hooks = isSourceHooks(arg1) ? arg1 : isSourceHooks(arg2) ? arg2 : arg3; // eslint-disable-line sonarjs/no-nested-conditional -- easier to read than the alternative */\n\t\tconst source = {\n\t\t\tdata: str,\n\t\t\tfilename,\n\t\t\tline: 1,\n\t\t\tcolumn: 1,\n\t\t\toffset: 0,\n\t\t\thooks,\n\t\t};\n\t\treturn this.validateSourceSync(source, options);\n\t}\n\n\t/**\n\t * Parse and validate HTML from [[Source]].\n\t *\n\t * @public\n\t * @param input - Source to parse.\n\t * @returns Report output.\n\t */\n\tpublic async validateSource(input: Source, configOverride?: ConfigData): Promise<Report> {\n\t\tconst source = normalizeSource(input);\n\t\tconst config = await this.getConfigFor(source.filename, configOverride);\n\t\tconst resolvers = this.configLoader.getResolvers();\n\t\tconst transformedSource = await transformSource(resolvers, config, source);\n\t\tconst engine = new Engine(config, Parser);\n\t\treturn engine.lint(transformedSource);\n\t}\n\n\t/**\n\t * Parse and validate HTML from [[Source]].\n\t *\n\t * @public\n\t * @param input - Source to parse.\n\t * @returns Report output.\n\t */\n\tpublic validateSourceSync(input: Source, configOverride?: ConfigData): Report {\n\t\tconst source = normalizeSource(input);\n\t\tconst config = this.getConfigForSync(source.filename, configOverride);\n\t\tconst resolvers = this.configLoader.getResolvers();\n\t\tconst transformedSource = transformSourceSync(resolvers, config, source);\n\t\tconst engine = new Engine(config, Parser);\n\t\treturn engine.lint(transformedSource);\n\t}\n\n\t/**\n\t * Parse and validate HTML from file.\n\t *\n\t * @public\n\t * @param filename - Filename to read and parse.\n\t * @returns Report output.\n\t */\n\tpublic async validateFile(filename: string, fs: TransformFS = defaultFS): Promise<Report> {\n\t\tconst config = await this.getConfigFor(filename);\n\t\tconst resolvers = this.configLoader.getResolvers();\n\t\tconst source = await transformFilename(resolvers, config, filename, fs);\n\t\tconst engine = new Engine(config, Parser);\n\t\treturn Promise.resolve(engine.lint(source));\n\t}\n\n\t/**\n\t * Parse and validate HTML from file.\n\t *\n\t * @public\n\t * @param filename - Filename to read and parse.\n\t * @returns Report output.\n\t */\n\tpublic validateFileSync(filename: string, fs: TransformFS = defaultFS): Report {\n\t\tconst config = this.getConfigForSync(filename);\n\t\tconst resolvers = this.configLoader.getResolvers();\n\t\tconst source = transformFilenameSync(resolvers, config, filename, fs);\n\t\tconst engine = new Engine(config, Parser);\n\t\treturn engine.lint(source);\n\t}\n\n\t/**\n\t * Parse and validate HTML from multiple files. Result is merged together to a\n\t * single report.\n\t *\n\t * @param filenames - Filenames to read and parse.\n\t * @returns Report output.\n\t */\n\tpublic async validateMultipleFiles(\n\t\tfilenames: string[],\n\t\tfs: TransformFS = defaultFS,\n\t): Promise<Report> {\n\t\treturn Reporter.merge(filenames.map((filename) => this.validateFile(filename, fs)));\n\t}\n\n\t/**\n\t * Parse and validate HTML from multiple files. Result is merged together to a\n\t * single report.\n\t *\n\t * @param filenames - Filenames to read and parse.\n\t * @returns Report output.\n\t */\n\tpublic validateMultipleFilesSync(filenames: string[], fs: TransformFS = defaultFS): Report {\n\t\treturn Reporter.merge(filenames.map((filename) => this.validateFileSync(filename, fs)));\n\t}\n\n\t/**\n\t * Returns true if the given filename can be validated.\n\t *\n\t * A file is considered to be validatable if the extension is `.html` or if a\n\t * transformer matches the filename.\n\t *\n\t * This is mostly useful for tooling to determine whenever to validate the\n\t * file or not. CLI tools will run on all the given files anyway.\n\t */\n\tpublic async canValidate(filename: string): Promise<boolean> {\n\t\t/* .html is always supported */\n\t\tif (filename.toLowerCase().endsWith(\".html\")) {\n\t\t\treturn true;\n\t\t}\n\n\t\t/* test if there is a matching transformer */\n\t\tconst config = await this.getConfigFor(filename);\n\t\treturn config.canTransform(filename);\n\t}\n\n\t/**\n\t * Returns true if the given filename can be validated.\n\t *\n\t * A file is considered to be validatable if the extension is `.html` or if a\n\t * transformer matches the filename.\n\t *\n\t * This is mostly useful for tooling to determine whenever to validate the\n\t * file or not. CLI tools will run on all the given files anyway.\n\t */\n\tpublic canValidateSync(filename: string): boolean {\n\t\t/* .html is always supported */\n\t\tif (filename.toLowerCase().endsWith(\".html\")) {\n\t\t\treturn true;\n\t\t}\n\n\t\t/* test if there is a matching transformer */\n\t\tconst config = this.getConfigForSync(filename);\n\t\treturn config.canTransform(filename);\n\t}\n\n\t/**\n\t * Tokenize filename and output all tokens.\n\t *\n\t * Using CLI this is enabled with `--dump-tokens`. Mostly useful for\n\t * debugging.\n\t *\n\t * @internal\n\t * @param filename - Filename to tokenize.\n\t */\n\tpublic async dumpTokens(filename: string, fs: TransformFS = defaultFS): Promise<TokenDump[]> {\n\t\tconst config = await this.getConfigFor(filename);\n\t\tconst resolvers = this.configLoader.getResolvers();\n\t\tconst source = await transformFilename(resolvers, config, filename, fs);\n\t\tconst engine = new Engine(config, Parser);\n\t\treturn engine.dumpTokens(source);\n\t}\n\n\t/**\n\t * Parse filename and output all events.\n\t *\n\t * Using CLI this is enabled with `--dump-events`. Mostly useful for\n\t * debugging.\n\t *\n\t * @internal\n\t * @param filename - Filename to dump events from.\n\t */\n\tpublic async dumpEvents(filename: string, fs: TransformFS = defaultFS): Promise<EventDump[]> {\n\t\tconst config = await this.getConfigFor(filename);\n\t\tconst resolvers = this.configLoader.getResolvers();\n\t\tconst source = await transformFilename(resolvers, config, filename, fs);\n\t\tconst engine = new Engine(config, Parser);\n\t\treturn engine.dumpEvents(source);\n\t}\n\n\t/**\n\t * Parse filename and output DOM tree.\n\t *\n\t * Using CLI this is enabled with `--dump-tree`. Mostly useful for\n\t * debugging.\n\t *\n\t * @internal\n\t * @param filename - Filename to dump DOM tree from.\n\t */\n\tpublic async dumpTree(filename: string, fs: TransformFS = defaultFS): Promise<string[]> {\n\t\tconst config = await this.getConfigFor(filename);\n\t\tconst resolvers = this.configLoader.getResolvers();\n\t\tconst source = await transformFilename(resolvers, config, filename, fs);\n\t\tconst engine = new Engine(config, Parser);\n\t\treturn engine.dumpTree(source);\n\t}\n\n\t/**\n\t * Transform filename and output source data.\n\t *\n\t * Using CLI this is enabled with `--dump-source`. Mostly useful for\n\t * debugging.\n\t *\n\t * @internal\n\t * @param filename - Filename to dump source from.\n\t */\n\tpublic async dumpSource(filename: string, fs: TransformFS = defaultFS): Promise<string[]> {\n\t\tconst config = await this.getConfigFor(filename);\n\t\tconst resolvers = this.configLoader.getResolvers();\n\t\tconst sources = await transformFilename(resolvers, config, filename, fs);\n\t\treturn sources.reduce<string[]>((result: string[], source: Source) => {\n\t\t\tconst line = String(source.line);\n\t\t\tconst column = String(source.column);\n\t\t\tconst offset = String(source.offset);\n\t\t\tresult.push(`Source ${source.filename}@${line}:${column} (offset: ${offset})`);\n\t\t\tif (source.transformedBy) {\n\t\t\t\tresult.push(\"Transformed by:\");\n\t\t\t\t/* eslint-disable-next-line sonarjs/no-misleading-array-reverse -- technical debt */\n\t\t\t\tresult = result.concat(source.transformedBy.reverse().map((name) => ` - ${name}`));\n\t\t\t}\n\t\t\tif (source.hooks && Object.keys(source.hooks).length > 0) {\n\t\t\t\tresult.push(\"Hooks\");\n\t\t\t\tfor (const [key, present] of Object.entries(source.hooks)) {\n\t\t\t\t\tif (present) {\n\t\t\t\t\t\tresult.push(` - ${key}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult.push(\"---\");\n\t\t\tresult = result.concat(source.data.split(\"\\n\"));\n\t\t\tresult.push(\"---\");\n\t\t\treturn result;\n\t\t}, []);\n\t}\n\n\t/**\n\t * Get effective configuration schema.\n\t */\n\tpublic getConfigurationSchema(): Promise<SchemaObject> {\n\t\treturn Promise.resolve(configurationSchema);\n\t}\n\n\t/**\n\t * Get effective metadata element schema.\n\t *\n\t * If a filename is given the configured plugins can extend the\n\t * schema. Filename must not be an existing file or a filetype normally\n\t * handled by html-validate but the path will be used when resolving\n\t * configuration. As a rule-of-thumb, set it to the elements json file.\n\t */\n\tpublic async getElementsSchema(filename?: string): Promise<SchemaObject> {\n\t\tconst config = await this.getConfigFor(filename ?? \"inline\");\n\t\tconst metaTable = config.getMetaTable();\n\t\treturn metaTable.getJSONSchema();\n\t}\n\n\t/**\n\t * Get effective metadata element schema.\n\t *\n\t * If a filename is given the configured plugins can extend the\n\t * schema. Filename must not be an existing file or a filetype normally\n\t * handled by html-validate but the path will be used when resolving\n\t * configuration. As a rule-of-thumb, set it to the elements json file.\n\t */\n\tpublic getElementsSchemaSync(filename?: string): SchemaObject {\n\t\tconst config = this.getConfigForSync(filename ?? \"inline\");\n\t\tconst metaTable = config.getMetaTable();\n\t\treturn metaTable.getJSONSchema();\n\t}\n\n\t/**\n\t * Get contextual documentation for the given rule. Configuration will be\n\t * resolved for given filename.\n\t *\n\t * @example\n\t *\n\t * ```js\n\t * const report = await htmlvalidate.validateFile(\"my-file.html\");\n\t * for (const result of report.results){\n\t *   for (const message of result.messages){\n\t *     const documentation = await htmlvalidate.getContextualDocumentation(message, result.filePath);\n\t *     // do something with documentation\n\t *   }\n\t * }\n\t * ```\n\t *\n\t * @public\n\t * @since 8.0.0\n\t * @param message - Message reported during validation\n\t * @param filename - Filename used to resolve configuration.\n\t * @returns Contextual documentation or `null` if the rule does not exist.\n\t */\n\tpublic getContextualDocumentation(\n\t\tmessage: Pick<Message, \"ruleId\" | \"context\">,\n\t\tfilename?: string,\n\t): Promise<RuleDocumentation | null>;\n\n\t/**\n\t * Get contextual documentation for the given rule using provided\n\t * configuration.\n\t *\n\t * @example\n\t *\n\t * ```js\n\t * const report = await htmlvalidate.validateFile(\"my-file.html\");\n\t * for (const result of report.results){\n\t *   for (const message of result.messages){\n\t *     const documentation = await htmlvalidate.getRuleDocumentation(message, result.filePath);\n\t *     // do something with documentation\n\t *   }\n\t * }\n\t * ```\n\t *\n\t * @public\n\t * @since 8.0.0\n\t * @param message - Message reported during validation\n\t * @param config - Configuration to use.\n\t * @returns Contextual documentation or `null` if the rule does not exist.\n\t */\n\tpublic getContextualDocumentation(\n\t\tmessage: Pick<Message, \"ruleId\" | \"context\">,\n\t\tconfig: ResolvedConfig | Promise<ResolvedConfig>,\n\t): Promise<RuleDocumentation | null>;\n\n\tpublic async getContextualDocumentation(\n\t\tmessage: Pick<Message, \"ruleId\" | \"context\">,\n\t\tfilenameOrConfig: ResolvedConfig | Promise<ResolvedConfig> | string = \"inline\",\n\t): Promise<RuleDocumentation | null> {\n\t\tconst config =\n\t\t\ttypeof filenameOrConfig === \"string\"\n\t\t\t\t? await this.getConfigFor(filenameOrConfig)\n\t\t\t\t: await filenameOrConfig;\n\t\tconst engine = new Engine(config, Parser);\n\t\treturn engine.getRuleDocumentation(message);\n\t}\n\n\t/**\n\t * Get contextual documentation for the given rule. Configuration will be\n\t * resolved for given filename.\n\t *\n\t * @example\n\t *\n\t * ```js\n\t * const report = htmlvalidate.validateFileSync(\"my-file.html\");\n\t * for (const result of report.results){\n\t *   for (const message of result.messages){\n\t *     const documentation = htmlvalidate.getRuleDocumentationSync(message, result.filePath);\n\t *     // do something with documentation\n\t *   }\n\t * }\n\t * ```\n\t *\n\t * @public\n\t * @since 8.0.0\n\t * @param message - Message reported during validation\n\t * @param filename - Filename used to resolve configuration.\n\t * @returns Contextual documentation or `null` if the rule does not exist.\n\t */\n\tpublic getContextualDocumentationSync(\n\t\tmessage: Pick<Message, \"ruleId\" | \"context\">,\n\t\tfilename?: string,\n\t): RuleDocumentation | null;\n\n\t/**\n\t * Get contextual documentation for the given rule using provided\n\t * configuration.\n\t *\n\t * @example\n\t *\n\t * ```js\n\t * const report = htmlvalidate.validateFileSync(\"my-file.html\");\n\t * for (const result of report.results){\n\t *   for (const message of result.messages){\n\t *     const documentation = htmlvalidate.getRuleDocumentationSync(message, result.filePath);\n\t *     // do something with documentation\n\t *   }\n\t * }\n\t * ```\n\t *\n\t * @public\n\t * @since 8.0.0\n\t * @param message - Message reported during validation\n\t * @param config - Configuration to use.\n\t * @returns Contextual documentation or `null` if the rule does not exist.\n\t */\n\tpublic getContextualDocumentationSync(\n\t\tmessage: Pick<Message, \"ruleId\" | \"context\">,\n\t\tconfig: ResolvedConfig,\n\t): RuleDocumentation | null;\n\n\tpublic getContextualDocumentationSync(\n\t\tmessage: Pick<Message, \"ruleId\" | \"context\">,\n\t\tfilenameOrConfig: ResolvedConfig | string = \"inline\",\n\t): RuleDocumentation | null {\n\t\tconst config =\n\t\t\ttypeof filenameOrConfig === \"string\"\n\t\t\t\t? this.getConfigForSync(filenameOrConfig)\n\t\t\t\t: filenameOrConfig;\n\t\tconst engine = new Engine(config, Parser);\n\t\treturn engine.getRuleDocumentation(message);\n\t}\n\n\t/**\n\t * Get contextual documentation for the given rule.\n\t *\n\t * Typical usage:\n\t *\n\t * ```js\n\t * const report = await htmlvalidate.validateFile(\"my-file.html\");\n\t * for (const result of report.results){\n\t *   const config = await htmlvalidate.getConfigFor(result.filePath);\n\t *   for (const message of result.messages){\n\t *     const documentation = await htmlvalidate.getRuleDocumentation(message.ruleId, config, message.context);\n\t *     // do something with documentation\n\t *   }\n\t * }\n\t * ```\n\t *\n\t * @public\n\t * @deprecated Deprecated since 8.0.0, use [[getContextualDocumentation]] instead.\n\t * @param ruleId - Rule to get documentation for.\n\t * @param config - If set it provides more accurate description by using the\n\t * correct configuration for the file.\n\t * @param context - If set to `Message.context` some rules can provide\n\t * contextual details and suggestions.\n\t */\n\tpublic async getRuleDocumentation(\n\t\truleId: string,\n\t\tconfig: ResolvedConfig | Promise<ResolvedConfig> | null = null,\n\t\tcontext: unknown | null = null,\n\t): Promise<RuleDocumentation | null> {\n\t\tconst c = config ?? this.getConfigFor(\"inline\");\n\t\tconst engine = new Engine(await c, Parser);\n\t\treturn engine.getRuleDocumentation({ ruleId, context });\n\t}\n\n\t/**\n\t * Get contextual documentation for the given rule.\n\t *\n\t * Typical usage:\n\t *\n\t * ```js\n\t * const report = htmlvalidate.validateFileSync(\"my-file.html\");\n\t * for (const result of report.results){\n\t *   const config = htmlvalidate.getConfigForSync(result.filePath);\n\t *   for (const message of result.messages){\n\t *     const documentation = htmlvalidate.getRuleDocumentationSync(message.ruleId, config, message.context);\n\t *     // do something with documentation\n\t *   }\n\t * }\n\t * ```\n\t *\n\t * @public\n\t * @deprecated Deprecated since 8.0.0, use [[getContextualDocumentationSync]] instead.\n\t * @param ruleId - Rule to get documentation for.\n\t * @param config - If set it provides more accurate description by using the\n\t * correct configuration for the file.\n\t * @param context - If set to `Message.context` some rules can provide\n\t * contextual details and suggestions.\n\t */\n\tpublic getRuleDocumentationSync(\n\t\truleId: string,\n\t\tconfig: ResolvedConfig | null = null,\n\t\tcontext: unknown | null = null,\n\t): RuleDocumentation | null {\n\t\tconst c = config ?? this.getConfigForSync(\"inline\");\n\t\tconst engine = new Engine(c, Parser);\n\t\treturn engine.getRuleDocumentation({ ruleId, context });\n\t}\n\n\t/**\n\t * Create a parser configured for given filename.\n\t *\n\t * @internal\n\t * @param source - Source to use.\n\t */\n\tpublic async getParserFor(source: Source): Promise<Parser> {\n\t\tconst config = await this.getConfigFor(source.filename);\n\t\treturn new Parser(config);\n\t}\n\n\t/**\n\t * Get configuration for given filename.\n\t *\n\t * See [[FileSystemConfigLoader]] for details.\n\t *\n\t * @public\n\t * @param filename - Filename to get configuration for.\n\t * @param configOverride - Configuration to apply last.\n\t */\n\tpublic getConfigFor(filename: string, configOverride?: ConfigData): Promise<ResolvedConfig> {\n\t\tconst config = this.configLoader.getConfigFor(filename, configOverride);\n\t\treturn Promise.resolve(config);\n\t}\n\n\t/**\n\t * Get configuration for given filename.\n\t *\n\t * See [[FileSystemConfigLoader]] for details.\n\t *\n\t * @public\n\t * @param filename - Filename to get configuration for.\n\t * @param configOverride - Configuration to apply last.\n\t */\n\tpublic getConfigForSync(filename: string, configOverride?: ConfigData): ResolvedConfig {\n\t\tconst config = this.configLoader.getConfigFor(filename, configOverride);\n\t\tif (isThenable(config)) {\n\t\t\tthrow new UserError(\"Cannot use asynchronous config loader with synchronous api\");\n\t\t}\n\t\treturn config;\n\t}\n\n\t/**\n\t * Get current configuration loader.\n\t *\n\t * @public\n\t * @since %version%\n\t * @returns Current configuration loader.\n\t */\n\t/* istanbul ignore next -- not testing setters/getters */\n\tpublic getConfigLoader(): ConfigLoader {\n\t\treturn this.configLoader;\n\t}\n\n\t/**\n\t * Set configuration loader.\n\t *\n\t * @public\n\t * @since %version%\n\t * @param loader - New configuration loader to use.\n\t */\n\t/* istanbul ignore next -- not testing setters/getters */\n\tpublic setConfigLoader(loader: ConfigLoader): void {\n\t\tthis.configLoader = loader;\n\t}\n\n\t/**\n\t * Flush configuration cache. Clears full cache unless a filename is given.\n\t *\n\t * See [[FileSystemConfigLoader]] for details.\n\t *\n\t * @public\n\t * @param filename - If set, only flush cache for given filename.\n\t */\n\tpublic flushConfigCache(filename?: string): void {\n\t\tthis.configLoader.flushCache(filename);\n\t}\n}\n","import fs from \"node:fs\";\nimport path from \"node:path\";\n\nlet cachedRootDir: string | null = null;\n\ninterface FSLike {\n\texistsSync(path: string): boolean;\n}\n\n/**\n * @internal\n */\nexport function determineRootDirImpl(intial: string, fs: FSLike): string {\n\t/* try to locate package.json */\n\tlet current = intial;\n\n\twhile (true) {\n\t\tconst search = path.join(current, \"package.json\");\n\t\tif (fs.existsSync(search)) {\n\t\t\treturn current;\n\t\t}\n\n\t\t/* get the parent directory */\n\t\tconst child = current;\n\t\tcurrent = path.dirname(current);\n\n\t\t/* stop if this is the root directory */\n\t\tif (current === child) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* default to working directory if no package.json is found */\n\treturn intial;\n}\n\n/**\n * Try to determine root directory based on the location of the closest\n * `package.json`. Fallbacks on `process.cwd()` if no package.json was found.\n *\n * @internal\n */\n/* istanbul ignore next: cached version of determineRootDirImpl, no need to test */\nexport function determineRootDir(): string {\n\tcachedRootDir ??= determineRootDirImpl(process.cwd(), fs);\n\treturn cachedRootDir;\n}\n","import path from \"node:path\";\n\n/**\n * @internal\n */\nexport function expandRelativePath<T>(value: string | T, { cwd }: { cwd: string }): string | T {\n\tif (typeof value === \"string\" && value.startsWith(\".\")) {\n\t\treturn path.normalize(path.join(cwd, value));\n\t} else {\n\t\treturn value;\n\t}\n}\n","import path from \"node:path\";\nimport { type MetaDataTable } from \"../../../meta\";\nimport { type Plugin } from \"../../../plugin\";\nimport { legacyRequire } from \"../../../resolve\";\nimport { type Transformer } from \"../../../transform\";\nimport { requireUncached } from \"../../../utils\";\nimport { type ConfigData } from \"../../config-data\";\nimport { ConfigError } from \"../../error\";\nimport { type Resolver, type ResolverOptions } from \"../resolver\";\nimport { determineRootDir } from \"./determine-root-dir\";\nimport { expandRelativePath } from \"./expand-relative-path\";\n\n/**\n * @internal\n */\nexport interface RequireError extends Error {\n\tcode: string;\n}\n\nfunction isRequireError(error: unknown): error is RequireError {\n\treturn Boolean(error && typeof error === \"object\" && \"code\" in error);\n}\n\nfunction isTransformer(value: Transformer | Plugin): value is Transformer {\n\treturn typeof value === \"function\";\n}\n\n/**\n * CommonJS resolver.\n *\n * @public\n * @since 8.8.0\n */\nexport type CommonJSResolver = Required<Resolver>;\n\n/**\n * CommonJS resolver.\n *\n * @public\n * @deprecated Deprecated alias for [[CommonJSResolver]].\n * @since 8.0.0\n */\nexport type NodeJSResolver = Required<Resolver>;\n\n/**\n * Create a new resolver for NodeJS packages using `require(..)`.\n *\n * If the module name contains `<rootDir>` (e.g. `<rootDir/foo`) it will be\n * expanded relative to the root directory either explicitly set by the\n * `rootDir` parameter or determined automatically by the closest `package.json`\n * file (starting at the current working directory).\n *\n * @public\n * @since 8.8.0\n */\nexport function cjsResolver(options: { rootDir?: string } = {}): CommonJSResolver {\n\tconst rootDir = options.rootDir ?? determineRootDir();\n\n\t/* eslint-disable-next-line @typescript-eslint/no-unnecessary-type-parameters -- technical debt, should return unknown as use explicit cast */\n\tfunction internalRequire<T = unknown>(id: string, { cache }: ResolverOptions): T | null {\n\t\tconst moduleName = id.replace(\"<rootDir>\", rootDir);\n\t\ttry {\n\t\t\t/* istanbul ignore else: the tests only runs the cached versions to get\n\t\t\t * unmodified access to `require`, the implementation of `requireUncached`\n\t\t\t * is assumed to be tested elsewhere */\n\t\t\tif (cache) {\n\t\t\t\treturn legacyRequire(moduleName) as T;\n\t\t\t} else {\n\t\t\t\treturn requireUncached(legacyRequire, moduleName) as T;\n\t\t\t}\n\t\t} catch (err: unknown) {\n\t\t\tif (isRequireError(err) && err.code === \"MODULE_NOT_FOUND\") {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\treturn {\n\t\tname: \"nodejs-resolver\",\n\n\t\tresolveElements(id: string, options: ResolverOptions): MetaDataTable | null {\n\t\t\treturn internalRequire(id, options);\n\t\t},\n\n\t\tresolveConfig(id: string, options: ResolverOptions): ConfigData | null {\n\t\t\tconst configData = internalRequire<ConfigData>(id, options);\n\t\t\tif (!configData) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t/* expand any relative paths */\n\t\t\tconst cwd = path.dirname(id);\n\t\t\tconst expand = <T>(value: string | T): string | T => expandRelativePath(value, { cwd });\n\n\t\t\tif (Array.isArray(configData.elements)) {\n\t\t\t\tconfigData.elements = configData.elements.map(expand);\n\t\t\t}\n\n\t\t\tif (Array.isArray(configData.extends)) {\n\t\t\t\tconfigData.extends = configData.extends.map(expand);\n\t\t\t}\n\n\t\t\tif (Array.isArray(configData.plugins)) {\n\t\t\t\tconfigData.plugins = configData.plugins.map(expand);\n\t\t\t}\n\n\t\t\treturn configData;\n\t\t},\n\n\t\tresolvePlugin(id: string, options: ResolverOptions): Plugin | null {\n\t\t\treturn internalRequire<Plugin>(id, options);\n\t\t},\n\n\t\tresolveTransformer(id: string, options: ResolverOptions): Transformer | null {\n\t\t\tconst mod = internalRequire<Transformer | Plugin>(id, options);\n\t\t\tif (!mod) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (isTransformer(mod)) {\n\t\t\t\treturn mod;\n\t\t\t}\n\n\t\t\t/* this is not a proper transformer, is it a plugin exposing a transformer? */\n\t\t\tif (mod.transformer) {\n\t\t\t\tthrow new ConfigError(\n\t\t\t\t\t`Module \"${id}\" is not a valid transformer. This looks like a plugin, did you forget to load the plugin first?`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthrow new ConfigError(`Module \"${id}\" is not a valid transformer.`);\n\t\t},\n\t};\n}\n\n/**\n * Create a new resolver for NodeJS packages using `require(..)`.\n *\n * If the module name contains `<rootDir>` (e.g. `<rootDir/foo`) it will be\n * expanded relative to the root directory either explicitly set by the\n * `rootDir` parameter or determined automatically by the closest `package.json`\n * file (starting at the current working directory).\n *\n * @public\n * @deprecated Deprecated alias for [[commonjsResolver]].\n * @since 8.0.0\n */\n/* istanbul ignore next -- deprecated alias */\n/* eslint-disable-next-line @typescript-eslint/no-deprecated -- deprecated but should still work */\nexport function nodejsResolver(options: { rootDir?: string } = {}): NodeJSResolver {\n\treturn cjsResolver(options);\n}\n","/* istanbul ignore file: this file is only for easier mocking */\n\n/**\n * Wrapper around import() so we can mock it in unittests.\n *\n * @internal\n */\nexport function importFunction(id: string): unknown {\n\treturn import(id);\n}\n","import { existsSync } from \"node:fs\";\nimport fs from \"node:fs/promises\";\nimport { pathToFileURL } from \"node:url\";\nimport { importResolve } from \"../../../resolve\";\nimport { UserError } from \"../../../error\";\nimport { type ResolverOptions } from \"../resolver\";\nimport { importFunction } from \"./import-function\";\n\n/**\n * @internal\n */\nexport interface ImportError extends Error {\n\tcode: string;\n\trequireStack?: string[];\n}\n\nasync function getModuleName(\n\tid: string,\n\t{ cache, rootDir }: { cache: boolean; rootDir: string },\n): Promise<URL> {\n\tconst moduleName = id.replace(\"<rootDir>\", rootDir);\n\tconst url = existsSync(id) ? pathToFileURL(id) : importResolve(moduleName);\n\n\tif (url.protocol !== \"file:\") {\n\t\treturn url;\n\t}\n\n\t/* istanbul ignore else: the tests only runs the cached versions */\n\tif (cache) {\n\t\treturn url;\n\t} else {\n\t\t/* Cachebusting in ESM is tricky, we cannot flush the cache of the old import\n\t\t * but a common workaround is to append ?something to the path. It only works\n\t\t * with absolute paths though so we must first use `import.meta.resolve(..)`\n\t\t * which doesn't play nice with CJS. Then we will leak memory each time a\n\t\t * fresh copy is loaded and there doesn't seem to be a way to deal with this\n\t\t * yet. We use the file mtime to at least try to retain the copy as long as\n\t\t * possible but this will fail for transitive imports but at least with\n\t\t * directly loaded configurations it would reload property. */\n\t\tconst stat = await fs.stat(url);\n\t\turl.searchParams.append(\"mtime\", String(stat.mtime.getTime()));\n\t\treturn url;\n\t}\n}\n\nfunction isImportError(error: unknown): error is ImportError {\n\treturn Boolean(error && typeof error === \"object\" && \"code\" in error);\n}\n\n/**\n * @internal\n */\nexport async function internalImport<T = unknown>(\n\tid: string,\n\trootDir: string,\n\t{ cache }: ResolverOptions,\n): Promise<T | null> {\n\t/* this is a workaround for rollup which mangles import attributes so we\n\t * cannot use `import(.., { with: { type: \"json\" } })` to import a json\n\t * file. */\n\t/* istanbul ignore if: workaround, not tested, should be removed if the compiler bug is fixed */\n\tif (id.endsWith(\".json\")) {\n\t\tconst content = await fs.readFile(id, \"utf-8\");\n\t\treturn JSON.parse(content) as T;\n\t}\n\n\ttry {\n\t\tconst url = await getModuleName(id, { cache, rootDir });\n\t\tif (url.protocol !== \"file:\") {\n\t\t\treturn null;\n\t\t}\n\t\tconst moduleName = url.toString();\n\t\tconst { default: defaultImport } = (await importFunction(moduleName)) as { default: T };\n\t\tif (!defaultImport) {\n\t\t\tthrow new UserError(`\"${id}\" does not have a default export`);\n\t\t}\n\t\treturn defaultImport;\n\t} catch (err: unknown) {\n\t\tif (isImportError(err) && err.code === \"MODULE_NOT_FOUND\" && !err.requireStack) {\n\t\t\treturn null;\n\t\t}\n\t\tthrow err;\n\t}\n}\n","import path from \"node:path\";\nimport { type MetaDataTable } from \"../../../meta\";\nimport { type Plugin } from \"../../../plugin\";\nimport { type Transformer } from \"../../../transform\";\nimport { type ConfigData } from \"../../config-data\";\nimport { ConfigError } from \"../../error\";\nimport { type Resolver, type ResolverOptions } from \"../resolver\";\nimport { determineRootDir } from \"./determine-root-dir\";\nimport { expandRelativePath } from \"./expand-relative-path\";\nimport { internalImport } from \"./internal-import\";\n\nfunction isTransformer(value: Transformer | Plugin): value is Transformer {\n\treturn typeof value === \"function\";\n}\n\n/**\n * ESM resolver.\n *\n * @public\n * @since 9.0.0\n */\nexport type ESMResolver = Required<Resolver>;\n\n/**\n * Create a new resolver for NodeJS packages using `import(..)`.\n *\n * If the module name contains `<rootDir>` (e.g. `<rootDir/foo`) it will be\n * expanded relative to the root directory either explicitly set by the\n * `rootDir` parameter or determined automatically by the closest `package.json`\n * file (starting at the current working directory).\n *\n * @public\n * @since 9.0.0\n */\nexport function esmResolver(options: { rootDir?: string } = {}): ESMResolver {\n\tconst rootDir = options.rootDir ?? determineRootDir();\n\n\treturn {\n\t\tname: \"esm-resolver\",\n\n\t\tresolveElements(id: string, options: ResolverOptions): Promise<MetaDataTable | null> {\n\t\t\treturn internalImport(id, rootDir, options);\n\t\t},\n\n\t\tasync resolveConfig(id: string, options: ResolverOptions): Promise<ConfigData | null> {\n\t\t\tconst configData = await internalImport<ConfigData>(id, rootDir, options);\n\t\t\tif (!configData) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t/* expand any relative paths */\n\t\t\tconst cwd = path.dirname(id);\n\t\t\tconst expand = <T>(value: string | T): string | T => expandRelativePath(value, { cwd });\n\n\t\t\tif (Array.isArray(configData.elements)) {\n\t\t\t\tconfigData.elements = configData.elements.map(expand);\n\t\t\t}\n\n\t\t\tif (Array.isArray(configData.extends)) {\n\t\t\t\tconfigData.extends = configData.extends.map(expand);\n\t\t\t}\n\n\t\t\tif (Array.isArray(configData.plugins)) {\n\t\t\t\tconfigData.plugins = configData.plugins.map(expand);\n\t\t\t}\n\n\t\t\treturn configData;\n\t\t},\n\n\t\tresolvePlugin(id: string, options: ResolverOptions): Promise<Plugin | null> {\n\t\t\treturn internalImport<Plugin>(id, rootDir, options);\n\t\t},\n\n\t\tasync resolveTransformer(id: string, options: ResolverOptions): Promise<Transformer | null> {\n\t\t\tconst mod = await internalImport<Transformer | Plugin>(id, rootDir, options);\n\t\t\tif (!mod) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (isTransformer(mod)) {\n\t\t\t\treturn mod;\n\t\t\t}\n\n\t\t\t/* this is not a proper transformer, is it a plugin exposing a transformer? */\n\t\t\tif (mod.transformer) {\n\t\t\t\tthrow new ConfigError(\n\t\t\t\t\t`Module \"${id}\" is not a valid transformer. This looks like a plugin, did you forget to load the plugin first?`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthrow new ConfigError(`Module \"${id}\" is not a valid transformer.`);\n\t\t},\n\t};\n}\n","import fs from \"node:fs\";\nimport path from \"node:path\";\nimport { Config } from \"../config\";\nimport { type ConfigData } from \"../config-data\";\nimport { ConfigLoader } from \"../config-loader\";\nimport { type ResolvedConfig } from \"../resolved-config\";\nimport { type Resolver } from \"../resolver\";\nimport { type FSLike, esmResolver } from \"../resolver/nodejs\";\nimport { isThenable } from \"../../utils\";\n\n/**\n * Options for [[FileSystemConfigLoader]].\n *\n * @public\n */\nexport interface FileSystemConfigLoaderOptions {\n\t/** An implementation of `fs` as needed by [[FileSystemConfigLoader]] */\n\tfs: FSLike;\n}\n\n/**\n * @internal\n */\nfunction findConfigurationFiles(fs: FSLike, directory: string): string[] {\n\treturn [\"json\", \"mjs\", \"cjs\", \"js\"]\n\t\t.map((extension) => path.join(directory, `.htmlvalidate.${extension}`))\n\t\t.filter((filePath) => fs.existsSync(filePath));\n}\n\nconst defaultResolvers: Resolver[] = [esmResolver()];\n\ntype ConstructorParametersDefault = [ConfigData?, Partial<FileSystemConfigLoaderOptions>?];\ntype ConstructorParametersResolver = [\n\tResolver[],\n\tConfigData?,\n\tPartial<FileSystemConfigLoaderOptions>?,\n];\ntype ConstructorParameters = ConstructorParametersDefault | ConstructorParametersResolver;\n\nfunction hasResolver(value: ConstructorParameters): value is ConstructorParametersResolver {\n\treturn Array.isArray(value[0]);\n}\n\n/**\n * Loads configuration by traversing filesystem.\n *\n * Configuration is read from three sources and in the following order:\n *\n * 1. Global configuration passed to constructor.\n * 2. Configuration files found when traversing the directory structure.\n * 3. Override passed to this function.\n *\n * The following configuration filenames are searched:\n *\n * - `.htmlvalidate.json`\n * - `.htmlvalidate.js`\n * - `.htmlvalidate.cjs`\n * - `.htmlvalidate.mjs`\n *\n * Global configuration is used when no configuration file is found. The\n * result is always merged with override if present.\n *\n * The `root` property set to `true` affects the configuration as following:\n *\n * 1. If set in override the override is returned as-is.\n * 2. If set in the global config the override is merged into global and\n * returned. No configuration files are searched.\n * 3. Setting `root` in configuration file only stops directory traversal.\n *\n * @public\n */\nexport class FileSystemConfigLoader extends ConfigLoader {\n\tprotected cache: Map<string, Config | null>;\n\tprivate fs: FSLike;\n\n\t/**\n\t * Create a filesystem configuration loader with default resolvers.\n\t *\n\t * @param fs - `fs` implementation,\n\t * @param config - Global configuration.\n\t * @param configFactory - Optional configuration factory.\n\t */\n\tpublic constructor(config?: ConfigData, options?: Partial<FileSystemConfigLoaderOptions>);\n\n\t/**\n\t * Create a filesystem configuration loader with custom resolvers.\n\t *\n\t * @param fs - `fs` implementation,\n\t * @param resolvers - Resolvers to use.\n\t * @param config - Global configuration.\n\t * @param configFactory - Optional configuration factory.\n\t */\n\tpublic constructor(\n\t\tresolvers: Resolver[],\n\t\tconfig?: ConfigData,\n\t\toptions?: Partial<FileSystemConfigLoaderOptions>,\n\t);\n\n\tpublic constructor(...args: ConstructorParameters) {\n\t\tif (hasResolver(args)) {\n\t\t\t/* istanbul ignore next */\n\t\t\tconst [resolvers, config, options = {}] = args;\n\t\t\tsuper(resolvers, config);\n\t\t\tthis.fs = /* istanbul ignore next */ options.fs ?? fs;\n\t\t} else {\n\t\t\t/* istanbul ignore next */\n\t\t\tconst [config, options = {}] = args;\n\t\t\tsuper(defaultResolvers, config);\n\t\t\tthis.fs = /* istanbul ignore next */ options.fs ?? fs;\n\t\t}\n\t\tthis.cache = new Map();\n\t}\n\n\t/**\n\t * Get configuration for given filename.\n\t *\n\t * @param filename - Filename to get configuration for.\n\t * @param configOverride - Configuration to merge final result with.\n\t */\n\tpublic override getConfigFor(\n\t\tfilename: string,\n\t\tconfigOverride?: ConfigData,\n\t): ResolvedConfig | Promise<ResolvedConfig> {\n\t\tconst override = this.loadFromObject(configOverride ?? {});\n\t\tif (isThenable(override)) {\n\t\t\treturn override.then((override) => {\n\t\t\t\treturn this._resolveAsync(filename, override);\n\t\t\t});\n\t\t} else {\n\t\t\treturn this._resolveSync1(filename, override);\n\t\t}\n\t}\n\n\t/**\n\t * Flush configuration cache.\n\t *\n\t * @param filename - If given only the cache for that file is flushed.\n\t */\n\tpublic override flushCache(filename?: string): void {\n\t\tif (filename) {\n\t\t\tthis.cache.delete(filename);\n\t\t} else {\n\t\t\tthis.cache.clear();\n\t\t}\n\t}\n\n\t/**\n\t * Load raw configuration from directory traversal.\n\t *\n\t * This configuration is not merged with global configuration and may return\n\t * `null` if no configuration files are found.\n\t */\n\n\tpublic fromFilename(filename: string): Config | Promise<Config | null> | null {\n\t\tif (filename === \"inline\") {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst cache = this.cache.get(filename);\n\t\tif (cache) {\n\t\t\treturn cache;\n\t\t}\n\n\t\tlet found = false;\n\t\tlet current = path.resolve(path.dirname(filename));\n\t\tlet config = this.empty();\n\n\t\twhile (true) {\n\t\t\t/* search configuration files in current directory */\n\t\t\tfor (const configFile of findConfigurationFiles(this.fs, current)) {\n\t\t\t\tconst local = this.loadFromFile(configFile);\n\n\t\t\t\t/* if the loader returns an async config we exit out of the synchronous\n\t\t\t\t * processing and enter the async method so we can resolve any promises\n\t\t\t\t * as we go */\n\t\t\t\tif (isThenable(local)) {\n\t\t\t\t\treturn this.fromFilenameAsync(filename);\n\t\t\t\t}\n\n\t\t\t\tfound = true;\n\n\t\t\t\tconst merged = local.merge(this.resolvers, config);\n\n\t\t\t\t/* istanbul ignore if -- should never happen */\n\t\t\t\tif (isThenable(merged)) {\n\t\t\t\t\tthrow new Error(\"internal error: async result ended up in sync path\");\n\t\t\t\t}\n\t\t\t\tconfig = merged;\n\t\t\t}\n\n\t\t\t/* stop if a configuration with \"root\" is set to true */\n\t\t\tif (config.isRootFound()) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* get the parent directory */\n\t\t\tconst child = current;\n\t\t\tcurrent = path.dirname(current);\n\n\t\t\t/* stop if this is the root directory */\n\t\t\tif (current === child) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* no config was found by loader, return null and let caller decide what to do */\n\t\tif (!found) {\n\t\t\tthis.cache.set(filename, null);\n\t\t\treturn null;\n\t\t}\n\n\t\tthis.cache.set(filename, config);\n\t\treturn config;\n\t}\n\n\t/**\n\t * Async version of [[fromFilename]].\n\t *\n\t * @internal\n\t */\n\tpublic async fromFilenameAsync(filename: string): Promise<Config | null> {\n\t\tif (filename === \"inline\") {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst cache = this.cache.get(filename);\n\t\tif (cache) {\n\t\t\treturn cache;\n\t\t}\n\n\t\tlet found = false;\n\t\tlet current = path.resolve(path.dirname(filename));\n\t\tlet config = this.empty();\n\n\t\twhile (true) {\n\t\t\t/* search configuration files in current directory */\n\t\t\tfor (const configFile of findConfigurationFiles(this.fs, current)) {\n\t\t\t\tconst local = await this.loadFromFile(configFile);\n\t\t\t\tfound = true;\n\t\t\t\tconfig = await local.merge(this.resolvers, config);\n\t\t\t}\n\n\t\t\t/* stop if a configuration with \"root\" is set to true */\n\t\t\tif (config.isRootFound()) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* get the parent directory */\n\t\t\tconst child = current;\n\t\t\tcurrent = path.dirname(current);\n\n\t\t\t/* stop if this is the root directory */\n\t\t\tif (current === child) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* no config was found by loader, return null and let caller decide what to do */\n\t\tif (!found) {\n\t\t\tthis.cache.set(filename, null);\n\t\t\treturn null;\n\t\t}\n\n\t\tthis.cache.set(filename, config);\n\t\treturn config;\n\t}\n\n\tprivate _merge(\n\t\tglobalConfig: Config,\n\t\toverride: Config,\n\t\tconfig: Config | null,\n\t): ResolvedConfig | Promise<ResolvedConfig> {\n\t\tconst merged = config\n\t\t\t? config.merge(this.resolvers, override)\n\t\t\t: globalConfig.merge(this.resolvers, override);\n\t\t/* istanbul ignore if -- covered by tsc, hard to recreate even with very specific testcases */\n\t\tif (isThenable(merged)) {\n\t\t\treturn merged.then((merged) => {\n\t\t\t\treturn merged.resolve();\n\t\t\t});\n\t\t} else {\n\t\t\treturn merged.resolve();\n\t\t}\n\t}\n\n\tprivate _resolveSync1(\n\t\tfilename: string,\n\t\toverride: Config,\n\t): ResolvedConfig | Promise<ResolvedConfig> {\n\t\tif (override.isRootFound()) {\n\t\t\treturn override.resolve();\n\t\t}\n\n\t\tconst globalConfig = this.getGlobalConfig();\n\t\t/* istanbul ignore if -- covered by tsc, hard to recreate even with very specific testcases */\n\t\tif (isThenable(globalConfig)) {\n\t\t\treturn globalConfig.then((globalConfig) => {\n\t\t\t\treturn this._resolveSync2(filename, override, globalConfig);\n\t\t\t});\n\t\t} else {\n\t\t\treturn this._resolveSync2(filename, override, globalConfig);\n\t\t}\n\t}\n\n\tprivate _resolveSync2(\n\t\tfilename: string,\n\t\toverride: Config,\n\t\tglobalConfig: Config,\n\t): ResolvedConfig | Promise<ResolvedConfig> {\n\t\t/* special case when the global configuration is marked as root, should not\n\t\t * try to load and more configuration files */\n\t\tif (globalConfig.isRootFound()) {\n\t\t\tconst merged = globalConfig.merge(this.resolvers, override);\n\t\t\t/* istanbul ignore if -- covered by tsc, hard to recreate even with very specific testcases */\n\t\t\tif (isThenable(merged)) {\n\t\t\t\treturn merged.then((merged) => {\n\t\t\t\t\treturn merged.resolve();\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn merged.resolve();\n\t\t\t}\n\t\t}\n\n\t\tconst config = this.fromFilename(filename);\n\t\tif (isThenable(config)) {\n\t\t\treturn config.then((config) => {\n\t\t\t\treturn this._merge(globalConfig, override, config);\n\t\t\t});\n\t\t} else {\n\t\t\treturn this._merge(globalConfig, override, config);\n\t\t}\n\t}\n\n\tprivate async _resolveAsync(filename: string, override: Config): Promise<ResolvedConfig> {\n\t\tif (override.isRootFound()) {\n\t\t\treturn override.resolve();\n\t\t}\n\n\t\tconst globalConfig = await this.getGlobalConfig();\n\n\t\t/* special case when the global configuration is marked as root, should not\n\t\t * try to load and more configuration files */\n\t\tif (globalConfig.isRootFound()) {\n\t\t\tconst merged = await globalConfig.merge(this.resolvers, override);\n\t\t\treturn merged.resolve();\n\t\t}\n\n\t\tconst config = await this.fromFilenameAsync(filename);\n\t\treturn this._merge(globalConfig, override, config);\n\t}\n\n\t/**\n\t * @internal For testing only\n\t */\n\tpublic _getInternalCache(): Map<string, Config | null> {\n\t\treturn this.cache;\n\t}\n\n\tprotected defaultConfig(): Config | Promise<Config> {\n\t\treturn Config.defaultConfig();\n\t}\n}\n","import kleur from \"kleur\";\nimport { version } from \"../generated/package\";\nimport { type CompatibilityOptions, compatibilityCheckImpl } from \"./compatibility-check\";\n\nconst defaults: CompatibilityOptions = {\n\tsilent: false,\n\tversion,\n\tlogger(text: string): void {\n\t\t/* eslint-disable-next-line no-console -- expected to log */\n\t\tconsole.error(kleur.red(text));\n\t},\n};\n\n/**\n * Tests if plugin is compatible with html-validate library. Unless the `silent`\n * option is used a warning is displayed on the console.\n *\n * @public\n * @since v5.0.0\n * @param name - Name of plugin\n * @param declared - What library versions the plugin support (e.g. declared peerDependencies)\n * @returns - `true` if version is compatible\n */\nexport function compatibilityCheck(\n\tname: string,\n\tdeclared: string,\n\toptions?: Partial<CompatibilityOptions>,\n): boolean {\n\treturn compatibilityCheckImpl(name, declared, {\n\t\t...defaults,\n\t\t...options,\n\t});\n}\n"],"names":["fs","ConfigLoader","StaticConfigLoader","normalizeSource","transformSource","Engine","Parser","transformSourceSync","transformFilename","transformFilenameSync","Reporter","configurationSchema","isThenable","UserError","path","isTransformer","options","ConfigError","existsSync","pathToFileURL","override","merged","globalConfig","config","Config","version","kleur","compatibilityCheckImpl"],"mappings":"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"}