{"version":3,"file":"core-browser.js","sources":["../../src/htmlvalidate.browser.ts","../../src/config/resolver/browser/import-function.ts","../../src/config/resolver/browser/esm-resolver.ts","../../src/utils/compatibility-check.browser.ts"],"sourcesContent":["import { type SchemaObject } from \"ajv\";\nimport { type ConfigData, type ResolvedConfig, ConfigLoader } from \"./config\";\nimport { normalizeSource, type Source } from \"./context\";\nimport { type SourceHooks } from \"./context/source\";\nimport { type EventDump, type TokenDump, Engine } from \"./engine\";\nimport { type Message } from \"./message\";\nimport { Parser } from \"./parser\";\nimport { type Report, Reporter } from \"./reporter\";\nimport { type RuleDocumentation } from \"./rule\";\nimport configurationSchema from \"./schema/config.json\";\nimport { StaticConfigLoader } from \"./config/loaders/static\";\nimport { isThenable } from \"./utils\";\nimport { UserError } from \"./error\";\nimport {\n\ttype TransformFS,\n\ttransformFilename,\n\ttransformFilenameSync,\n\ttransformSource,\n\ttransformSourceSync,\n} from \"./transform\";\n\nfunction isSourceHooks(value: any): value is SourceHooks {\n\tif (!value || typeof value === \"string\") {\n\t\treturn false;\n\t}\n\treturn Boolean(value.processAttribute ?? value.processElement);\n}\n\nfunction isConfigData(value: any): value is ConfigData {\n\tif (!value || typeof value === \"string\") {\n\t\treturn false;\n\t}\n\treturn !(value.processAttribute ?? value.processElement);\n}\n\n/**\n * Primary API for using HTML-validate.\n *\n * Provides high-level abstractions for common operations.\n *\n * @public\n */\nexport class HtmlValidate {\n\tprotected configLoader: ConfigLoader;\n\n\t/**\n\t * Create a new validator.\n\t *\n\t * @public\n\t * @param configLoader - Use a custom configuration loader.\n\t * @param config - If set it provides the global default configuration. By\n\t * default `Config.defaultConfig()` is used.\n\t */\n\tpublic constructor(config?: ConfigData);\n\tpublic constructor(configLoader: ConfigLoader);\n\tpublic constructor(arg?: ConfigLoader | ConfigData) {\n\t\tconst [loader, config] = arg instanceof ConfigLoader ? [arg, undefined] : [undefined, arg];\n\t\tthis.configLoader = loader ?? new StaticConfigLoader(config);\n\t}\n\n\t/**\n\t * Parse and validate HTML from string.\n\t *\n\t * @public\n\t * @param str - Text to parse.\n\t * @param filename - If set configuration is loaded for given filename.\n\t * @param hooks - Optional hooks (see [[Source]]) for definition.\n\t * @returns Report output.\n\t */\n\t/* eslint-disable @typescript-eslint/unified-signatures -- for easier readability */\n\tpublic validateString(str: string): Promise<Report>;\n\tpublic validateString(str: string, filename: string): Promise<Report>;\n\tpublic validateString(str: string, hooks: SourceHooks): Promise<Report>;\n\tpublic validateString(str: string, options: ConfigData): Promise<Report>;\n\tpublic validateString(str: string, filename: string, hooks: SourceHooks): Promise<Report>;\n\tpublic validateString(str: string, filename: string, options: ConfigData): Promise<Report>;\n\tpublic validateString(\n\t\tstr: string,\n\t\tfilename: string,\n\t\toptions: ConfigData,\n\t\thooks: SourceHooks,\n\t): Promise<Report>;\n\t/* eslint-enable @typescript-eslint/unified-signatures */\n\tpublic validateString(\n\t\tstr: string,\n\t\targ1?: string | SourceHooks | ConfigData,\n\t\targ2?: SourceHooks | ConfigData,\n\t\targ3?: SourceHooks,\n\t): Promise<Report> {\n\t\tconst filename = typeof arg1 === \"string\" ? arg1 : \"inline\";\n\t\tconst options = isConfigData(arg1) ? arg1 : isConfigData(arg2) ? arg2 : undefined; // eslint-disable-line sonarjs/no-nested-conditional -- easier to read than the alternative */\n\t\tconst hooks = isSourceHooks(arg1) ? arg1 : isSourceHooks(arg2) ? arg2 : arg3; // eslint-disable-line sonarjs/no-nested-conditional -- easier to read than the alternative */\n\t\tconst source = {\n\t\t\tdata: str,\n\t\t\tfilename,\n\t\t\tline: 1,\n\t\t\tcolumn: 1,\n\t\t\toffset: 0,\n\t\t\thooks,\n\t\t};\n\t\treturn this.validateSource(source, options);\n\t}\n\n\t/**\n\t * Parse and validate HTML from string.\n\t *\n\t * @public\n\t * @param str - Text to parse.\n\t * @param filename - If set configuration is loaded for given filename.\n\t * @param hooks - Optional hooks (see [[Source]]) for definition.\n\t * @returns Report output.\n\t */\n\t/* eslint-disable @typescript-eslint/unified-signatures -- for easier readability */\n\tpublic validateStringSync(str: string): Report;\n\tpublic validateStringSync(str: string, filename: string): Report;\n\tpublic validateStringSync(str: string, hooks: SourceHooks): Report;\n\tpublic validateStringSync(str: string, options: ConfigData): Report;\n\tpublic validateStringSync(str: string, filename: string, hooks: SourceHooks): Report;\n\tpublic validateStringSync(str: string, filename: string, options: ConfigData): Report;\n\tpublic validateStringSync(\n\t\tstr: string,\n\t\tfilename: string,\n\t\toptions: ConfigData,\n\t\thooks: SourceHooks,\n\t): Report;\n\t/* eslint-enable @typescript-eslint/unified-signatures */\n\tpublic validateStringSync(\n\t\tstr: string,\n\t\targ1?: string | SourceHooks | ConfigData,\n\t\targ2?: SourceHooks | ConfigData,\n\t\targ3?: SourceHooks,\n\t): Report {\n\t\tconst filename = typeof arg1 === \"string\" ? arg1 : \"inline\";\n\t\tconst options = isConfigData(arg1) ? arg1 : isConfigData(arg2) ? arg2 : undefined; // eslint-disable-line sonarjs/no-nested-conditional -- easier to read than the alternative */\n\t\tconst hooks = isSourceHooks(arg1) ? arg1 : isSourceHooks(arg2) ? arg2 : arg3; // eslint-disable-line sonarjs/no-nested-conditional -- easier to read than the alternative */\n\t\tconst source = {\n\t\t\tdata: str,\n\t\t\tfilename,\n\t\t\tline: 1,\n\t\t\tcolumn: 1,\n\t\t\toffset: 0,\n\t\t\thooks,\n\t\t};\n\t\treturn this.validateSourceSync(source, options);\n\t}\n\n\t/**\n\t * Parse and validate HTML from [[Source]].\n\t *\n\t * @public\n\t * @param input - Source to parse.\n\t * @returns Report output.\n\t */\n\tpublic async validateSource(input: Source, configOverride?: ConfigData): Promise<Report> {\n\t\tconst source = normalizeSource(input);\n\t\tconst config = await this.getConfigFor(source.filename, configOverride);\n\t\tconst resolvers = this.configLoader.getResolvers();\n\t\tconst transformedSource = await transformSource(resolvers, config, source);\n\t\tconst engine = new Engine(config, Parser);\n\t\treturn engine.lint(transformedSource);\n\t}\n\n\t/**\n\t * Parse and validate HTML from [[Source]].\n\t *\n\t * @public\n\t * @param input - Source to parse.\n\t * @returns Report output.\n\t */\n\tpublic validateSourceSync(input: Source, configOverride?: ConfigData): Report {\n\t\tconst source = normalizeSource(input);\n\t\tconst config = this.getConfigForSync(source.filename, configOverride);\n\t\tconst resolvers = this.configLoader.getResolvers();\n\t\tconst transformedSource = transformSourceSync(resolvers, config, source);\n\t\tconst engine = new Engine(config, Parser);\n\t\treturn engine.lint(transformedSource);\n\t}\n\n\t/**\n\t * Parse and validate HTML from file.\n\t *\n\t * @public\n\t * @param filename - Filename to read and parse.\n\t * @returns Report output.\n\t */\n\tpublic async validateFile(filename: string, fs: TransformFS): Promise<Report> {\n\t\tconst config = await this.getConfigFor(filename);\n\t\tconst resolvers = this.configLoader.getResolvers();\n\t\tconst source = await transformFilename(resolvers, config, filename, fs);\n\t\tconst engine = new Engine(config, Parser);\n\t\treturn Promise.resolve(engine.lint(source));\n\t}\n\n\t/**\n\t * Parse and validate HTML from file.\n\t *\n\t * @public\n\t * @param filename - Filename to read and parse.\n\t * @returns Report output.\n\t */\n\tpublic validateFileSync(filename: string, fs: TransformFS): Report {\n\t\tconst config = this.getConfigForSync(filename);\n\t\tconst resolvers = this.configLoader.getResolvers();\n\t\tconst source = transformFilenameSync(resolvers, config, filename, fs);\n\t\tconst engine = new Engine(config, Parser);\n\t\treturn engine.lint(source);\n\t}\n\n\t/**\n\t * Parse and validate HTML from multiple files. Result is merged together to a\n\t * single report.\n\t *\n\t * @param filenames - Filenames to read and parse.\n\t * @returns Report output.\n\t */\n\tpublic async validateMultipleFiles(filenames: string[], fs: TransformFS): Promise<Report> {\n\t\treturn Reporter.merge(filenames.map((filename) => this.validateFile(filename, fs)));\n\t}\n\n\t/**\n\t * Parse and validate HTML from multiple files. Result is merged together to a\n\t * single report.\n\t *\n\t * @param filenames - Filenames to read and parse.\n\t * @returns Report output.\n\t */\n\tpublic validateMultipleFilesSync(filenames: string[], fs: TransformFS): Report {\n\t\treturn Reporter.merge(filenames.map((filename) => this.validateFileSync(filename, fs)));\n\t}\n\n\t/**\n\t * Returns true if the given filename can be validated.\n\t *\n\t * A file is considered to be validatable if the extension is `.html` or if a\n\t * transformer matches the filename.\n\t *\n\t * This is mostly useful for tooling to determine whenever to validate the\n\t * file or not. CLI tools will run on all the given files anyway.\n\t */\n\tpublic async canValidate(filename: string): Promise<boolean> {\n\t\t/* .html is always supported */\n\t\tif (filename.toLowerCase().endsWith(\".html\")) {\n\t\t\treturn true;\n\t\t}\n\n\t\t/* test if there is a matching transformer */\n\t\tconst config = await this.getConfigFor(filename);\n\t\treturn config.canTransform(filename);\n\t}\n\n\t/**\n\t * Returns true if the given filename can be validated.\n\t *\n\t * A file is considered to be validatable if the extension is `.html` or if a\n\t * transformer matches the filename.\n\t *\n\t * This is mostly useful for tooling to determine whenever to validate the\n\t * file or not. CLI tools will run on all the given files anyway.\n\t */\n\tpublic canValidateSync(filename: string): boolean {\n\t\t/* .html is always supported */\n\t\tif (filename.toLowerCase().endsWith(\".html\")) {\n\t\t\treturn true;\n\t\t}\n\n\t\t/* test if there is a matching transformer */\n\t\tconst config = this.getConfigForSync(filename);\n\t\treturn config.canTransform(filename);\n\t}\n\n\t/**\n\t * Tokenize filename and output all tokens.\n\t *\n\t * Using CLI this is enabled with `--dump-tokens`. Mostly useful for\n\t * debugging.\n\t *\n\t * @internal\n\t * @param filename - Filename to tokenize.\n\t */\n\tpublic async dumpTokens(filename: string, fs: TransformFS): Promise<TokenDump[]> {\n\t\tconst config = await this.getConfigFor(filename);\n\t\tconst resolvers = this.configLoader.getResolvers();\n\t\tconst source = await transformFilename(resolvers, config, filename, fs);\n\t\tconst engine = new Engine(config, Parser);\n\t\treturn engine.dumpTokens(source);\n\t}\n\n\t/**\n\t * Parse filename and output all events.\n\t *\n\t * Using CLI this is enabled with `--dump-events`. Mostly useful for\n\t * debugging.\n\t *\n\t * @internal\n\t * @param filename - Filename to dump events from.\n\t */\n\tpublic async dumpEvents(filename: string, fs: TransformFS): Promise<EventDump[]> {\n\t\tconst config = await this.getConfigFor(filename);\n\t\tconst resolvers = this.configLoader.getResolvers();\n\t\tconst source = await transformFilename(resolvers, config, filename, fs);\n\t\tconst engine = new Engine(config, Parser);\n\t\treturn engine.dumpEvents(source);\n\t}\n\n\t/**\n\t * Parse filename and output DOM tree.\n\t *\n\t * Using CLI this is enabled with `--dump-tree`. Mostly useful for\n\t * debugging.\n\t *\n\t * @internal\n\t * @param filename - Filename to dump DOM tree from.\n\t */\n\tpublic async dumpTree(filename: string, fs: TransformFS): Promise<string[]> {\n\t\tconst config = await this.getConfigFor(filename);\n\t\tconst resolvers = this.configLoader.getResolvers();\n\t\tconst source = await transformFilename(resolvers, config, filename, fs);\n\t\tconst engine = new Engine(config, Parser);\n\t\treturn engine.dumpTree(source);\n\t}\n\n\t/**\n\t * Transform filename and output source data.\n\t *\n\t * Using CLI this is enabled with `--dump-source`. Mostly useful for\n\t * debugging.\n\t *\n\t * @internal\n\t * @param filename - Filename to dump source from.\n\t */\n\tpublic async dumpSource(filename: string, fs: TransformFS): Promise<string[]> {\n\t\tconst config = await this.getConfigFor(filename);\n\t\tconst resolvers = this.configLoader.getResolvers();\n\t\tconst sources = await transformFilename(resolvers, config, filename, fs);\n\t\treturn sources.reduce<string[]>((result: string[], source: Source) => {\n\t\t\tconst line = String(source.line);\n\t\t\tconst column = String(source.column);\n\t\t\tconst offset = String(source.offset);\n\t\t\tresult.push(`Source ${source.filename}@${line}:${column} (offset: ${offset})`);\n\t\t\tif (source.transformedBy) {\n\t\t\t\tresult.push(\"Transformed by:\");\n\t\t\t\t/* eslint-disable-next-line sonarjs/no-misleading-array-reverse -- technical debt */\n\t\t\t\tresult = result.concat(source.transformedBy.reverse().map((name) => ` - ${name}`));\n\t\t\t}\n\t\t\tif (source.hooks && Object.keys(source.hooks).length > 0) {\n\t\t\t\tresult.push(\"Hooks\");\n\t\t\t\tfor (const [key, present] of Object.entries(source.hooks)) {\n\t\t\t\t\tif (present) {\n\t\t\t\t\t\tresult.push(` - ${key}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult.push(\"---\");\n\t\t\tresult = result.concat(source.data.split(\"\\n\"));\n\t\t\tresult.push(\"---\");\n\t\t\treturn result;\n\t\t}, []);\n\t}\n\n\t/**\n\t * Get effective configuration schema.\n\t */\n\tpublic getConfigurationSchema(): Promise<SchemaObject> {\n\t\treturn Promise.resolve(configurationSchema);\n\t}\n\n\t/**\n\t * Get effective metadata element schema.\n\t *\n\t * If a filename is given the configured plugins can extend the\n\t * schema. Filename must not be an existing file or a filetype normally\n\t * handled by html-validate but the path will be used when resolving\n\t * configuration. As a rule-of-thumb, set it to the elements json file.\n\t */\n\tpublic async getElementsSchema(filename?: string): Promise<SchemaObject> {\n\t\tconst config = await this.getConfigFor(filename ?? \"inline\");\n\t\tconst metaTable = config.getMetaTable();\n\t\treturn metaTable.getJSONSchema();\n\t}\n\n\t/**\n\t * Get effective metadata element schema.\n\t *\n\t * If a filename is given the configured plugins can extend the\n\t * schema. Filename must not be an existing file or a filetype normally\n\t * handled by html-validate but the path will be used when resolving\n\t * configuration. As a rule-of-thumb, set it to the elements json file.\n\t */\n\tpublic getElementsSchemaSync(filename?: string): SchemaObject {\n\t\tconst config = this.getConfigForSync(filename ?? \"inline\");\n\t\tconst metaTable = config.getMetaTable();\n\t\treturn metaTable.getJSONSchema();\n\t}\n\n\t/**\n\t * Get contextual documentation for the given rule. Configuration will be\n\t * resolved for given filename.\n\t *\n\t * @example\n\t *\n\t * ```js\n\t * const report = await htmlvalidate.validateFile(\"my-file.html\");\n\t * for (const result of report.results){\n\t *   for (const message of result.messages){\n\t *     const documentation = await htmlvalidate.getContextualDocumentation(message, result.filePath);\n\t *     // do something with documentation\n\t *   }\n\t * }\n\t * ```\n\t *\n\t * @public\n\t * @since 8.0.0\n\t * @param message - Message reported during validation\n\t * @param filename - Filename used to resolve configuration.\n\t * @returns Contextual documentation or `null` if the rule does not exist.\n\t */\n\tpublic getContextualDocumentation(\n\t\tmessage: Pick<Message, \"ruleId\" | \"context\">,\n\t\tfilename?: string,\n\t): Promise<RuleDocumentation | null>;\n\n\t/**\n\t * Get contextual documentation for the given rule using provided\n\t * configuration.\n\t *\n\t * @example\n\t *\n\t * ```js\n\t * const report = await htmlvalidate.validateFile(\"my-file.html\");\n\t * for (const result of report.results){\n\t *   for (const message of result.messages){\n\t *     const documentation = await htmlvalidate.getRuleDocumentation(message, result.filePath);\n\t *     // do something with documentation\n\t *   }\n\t * }\n\t * ```\n\t *\n\t * @public\n\t * @since 8.0.0\n\t * @param message - Message reported during validation\n\t * @param config - Configuration to use.\n\t * @returns Contextual documentation or `null` if the rule does not exist.\n\t */\n\tpublic getContextualDocumentation(\n\t\tmessage: Pick<Message, \"ruleId\" | \"context\">,\n\t\tconfig: ResolvedConfig | Promise<ResolvedConfig>,\n\t): Promise<RuleDocumentation | null>;\n\n\tpublic async getContextualDocumentation(\n\t\tmessage: Pick<Message, \"ruleId\" | \"context\">,\n\t\tfilenameOrConfig: ResolvedConfig | Promise<ResolvedConfig> | string = \"inline\",\n\t): Promise<RuleDocumentation | null> {\n\t\tconst config =\n\t\t\ttypeof filenameOrConfig === \"string\"\n\t\t\t\t? await this.getConfigFor(filenameOrConfig)\n\t\t\t\t: await filenameOrConfig;\n\t\tconst engine = new Engine(config, Parser);\n\t\treturn engine.getRuleDocumentation(message);\n\t}\n\n\t/**\n\t * Get contextual documentation for the given rule. Configuration will be\n\t * resolved for given filename.\n\t *\n\t * @example\n\t *\n\t * ```js\n\t * const report = htmlvalidate.validateFileSync(\"my-file.html\");\n\t * for (const result of report.results){\n\t *   for (const message of result.messages){\n\t *     const documentation = htmlvalidate.getRuleDocumentationSync(message, result.filePath);\n\t *     // do something with documentation\n\t *   }\n\t * }\n\t * ```\n\t *\n\t * @public\n\t * @since 8.0.0\n\t * @param message - Message reported during validation\n\t * @param filename - Filename used to resolve configuration.\n\t * @returns Contextual documentation or `null` if the rule does not exist.\n\t */\n\tpublic getContextualDocumentationSync(\n\t\tmessage: Pick<Message, \"ruleId\" | \"context\">,\n\t\tfilename?: string,\n\t): RuleDocumentation | null;\n\n\t/**\n\t * Get contextual documentation for the given rule using provided\n\t * configuration.\n\t *\n\t * @example\n\t *\n\t * ```js\n\t * const report = htmlvalidate.validateFileSync(\"my-file.html\");\n\t * for (const result of report.results){\n\t *   for (const message of result.messages){\n\t *     const documentation = htmlvalidate.getRuleDocumentationSync(message, result.filePath);\n\t *     // do something with documentation\n\t *   }\n\t * }\n\t * ```\n\t *\n\t * @public\n\t * @since 8.0.0\n\t * @param message - Message reported during validation\n\t * @param config - Configuration to use.\n\t * @returns Contextual documentation or `null` if the rule does not exist.\n\t */\n\tpublic getContextualDocumentationSync(\n\t\tmessage: Pick<Message, \"ruleId\" | \"context\">,\n\t\tconfig: ResolvedConfig,\n\t): RuleDocumentation | null;\n\n\tpublic getContextualDocumentationSync(\n\t\tmessage: Pick<Message, \"ruleId\" | \"context\">,\n\t\tfilenameOrConfig: ResolvedConfig | string = \"inline\",\n\t): RuleDocumentation | null {\n\t\tconst config =\n\t\t\ttypeof filenameOrConfig === \"string\"\n\t\t\t\t? this.getConfigForSync(filenameOrConfig)\n\t\t\t\t: filenameOrConfig;\n\t\tconst engine = new Engine(config, Parser);\n\t\treturn engine.getRuleDocumentation(message);\n\t}\n\n\t/**\n\t * Get contextual documentation for the given rule.\n\t *\n\t * Typical usage:\n\t *\n\t * ```js\n\t * const report = await htmlvalidate.validateFile(\"my-file.html\");\n\t * for (const result of report.results){\n\t *   const config = await htmlvalidate.getConfigFor(result.filePath);\n\t *   for (const message of result.messages){\n\t *     const documentation = await htmlvalidate.getRuleDocumentation(message.ruleId, config, message.context);\n\t *     // do something with documentation\n\t *   }\n\t * }\n\t * ```\n\t *\n\t * @public\n\t * @deprecated Deprecated since 8.0.0, use [[getContextualDocumentation]] instead.\n\t * @param ruleId - Rule to get documentation for.\n\t * @param config - If set it provides more accurate description by using the\n\t * correct configuration for the file.\n\t * @param context - If set to `Message.context` some rules can provide\n\t * contextual details and suggestions.\n\t */\n\tpublic async getRuleDocumentation(\n\t\truleId: string,\n\t\tconfig: ResolvedConfig | Promise<ResolvedConfig> | null = null,\n\t\tcontext: unknown | null = null,\n\t): Promise<RuleDocumentation | null> {\n\t\tconst c = config ?? this.getConfigFor(\"inline\");\n\t\tconst engine = new Engine(await c, Parser);\n\t\treturn engine.getRuleDocumentation({ ruleId, context });\n\t}\n\n\t/**\n\t * Get contextual documentation for the given rule.\n\t *\n\t * Typical usage:\n\t *\n\t * ```js\n\t * const report = htmlvalidate.validateFileSync(\"my-file.html\");\n\t * for (const result of report.results){\n\t *   const config = htmlvalidate.getConfigForSync(result.filePath);\n\t *   for (const message of result.messages){\n\t *     const documentation = htmlvalidate.getRuleDocumentationSync(message.ruleId, config, message.context);\n\t *     // do something with documentation\n\t *   }\n\t * }\n\t * ```\n\t *\n\t * @public\n\t * @deprecated Deprecated since 8.0.0, use [[getContextualDocumentationSync]] instead.\n\t * @param ruleId - Rule to get documentation for.\n\t * @param config - If set it provides more accurate description by using the\n\t * correct configuration for the file.\n\t * @param context - If set to `Message.context` some rules can provide\n\t * contextual details and suggestions.\n\t */\n\tpublic getRuleDocumentationSync(\n\t\truleId: string,\n\t\tconfig: ResolvedConfig | null = null,\n\t\tcontext: unknown | null = null,\n\t): RuleDocumentation | null {\n\t\tconst c = config ?? this.getConfigForSync(\"inline\");\n\t\tconst engine = new Engine(c, Parser);\n\t\treturn engine.getRuleDocumentation({ ruleId, context });\n\t}\n\n\t/**\n\t * Create a parser configured for given filename.\n\t *\n\t * @internal\n\t * @param source - Source to use.\n\t */\n\tpublic async getParserFor(source: Source): Promise<Parser> {\n\t\tconst config = await this.getConfigFor(source.filename);\n\t\treturn new Parser(config);\n\t}\n\n\t/**\n\t * Get configuration for given filename.\n\t *\n\t * See [[FileSystemConfigLoader]] for details.\n\t *\n\t * @public\n\t * @param filename - Filename to get configuration for.\n\t * @param configOverride - Configuration to apply last.\n\t */\n\tpublic getConfigFor(filename: string, configOverride?: ConfigData): Promise<ResolvedConfig> {\n\t\tconst config = this.configLoader.getConfigFor(filename, configOverride);\n\t\treturn Promise.resolve(config);\n\t}\n\n\t/**\n\t * Get configuration for given filename.\n\t *\n\t * See [[FileSystemConfigLoader]] for details.\n\t *\n\t * @public\n\t * @param filename - Filename to get configuration for.\n\t * @param configOverride - Configuration to apply last.\n\t */\n\tpublic getConfigForSync(filename: string, configOverride?: ConfigData): ResolvedConfig {\n\t\tconst config = this.configLoader.getConfigFor(filename, configOverride);\n\t\tif (isThenable(config)) {\n\t\t\tthrow new UserError(\"Cannot use asynchronous config loader with synchronous api\");\n\t\t}\n\t\treturn config;\n\t}\n\n\t/**\n\t * Get current configuration loader.\n\t *\n\t * @public\n\t * @since %version%\n\t * @returns Current configuration loader.\n\t */\n\t/* istanbul ignore next -- not testing setters/getters */\n\tpublic getConfigLoader(): ConfigLoader {\n\t\treturn this.configLoader;\n\t}\n\n\t/**\n\t * Set configuration loader.\n\t *\n\t * @public\n\t * @since %version%\n\t * @param loader - New configuration loader to use.\n\t */\n\t/* istanbul ignore next -- not testing setters/getters */\n\tpublic setConfigLoader(loader: ConfigLoader): void {\n\t\tthis.configLoader = loader;\n\t}\n\n\t/**\n\t * Flush configuration cache. Clears full cache unless a filename is given.\n\t *\n\t * See [[FileSystemConfigLoader]] for details.\n\t *\n\t * @public\n\t * @param filename - If set, only flush cache for given filename.\n\t */\n\tpublic flushConfigCache(filename?: string): void {\n\t\tthis.configLoader.flushCache(filename);\n\t}\n}\n","/* istanbul ignore file: this file is only for easier mocking */\n\n/**\n * Wrapper around import() so we can mock it in unittests.\n *\n * @internal\n */\nexport function importFunction(id: string): unknown {\n\treturn import(id);\n}\n","import { UserError } from \"../../../error\";\nimport { type MetaDataTable } from \"../../../meta\";\nimport { type Plugin } from \"../../../plugin\";\nimport { type Transformer } from \"../../../transform\";\nimport { type ConfigData } from \"../../config-data\";\nimport { type Resolver } from \"../resolver\";\nimport { importFunction } from \"./import-function\";\n\nexport async function internalImport<T = unknown>(id: string): Promise<T | null> {\n\tconst { default: defaultImport } = (await importFunction(id)) as { default?: T };\n\tif (!defaultImport) {\n\t\tthrow new UserError(`\"${id}\" does not have a default export`);\n\t}\n\treturn defaultImport;\n}\n\n/**\n * ESM resolver.\n *\n * @public\n * @since 9.0.0\n */\nexport type ESMResolver = Required<Resolver>;\n\n/**\n * Create a new resolver for  using `import(..)`.\n *\n * @public\n * @since 9.0.0\n */\nexport function esmResolver(): ESMResolver {\n\treturn {\n\t\tname: \"esm-resolver\",\n\n\t\tresolveElements(id: string): Promise<MetaDataTable | null> {\n\t\t\treturn internalImport(id);\n\t\t},\n\n\t\tresolveConfig(id: string): Promise<ConfigData | null> {\n\t\t\treturn internalImport(id);\n\t\t},\n\n\t\tresolvePlugin(id: string): Promise<Plugin | null> {\n\t\t\treturn internalImport<Plugin>(id);\n\t\t},\n\n\t\tasync resolveTransformer(id: string): Promise<Transformer | null> {\n\t\t\treturn internalImport(id);\n\t\t},\n\t};\n}\n","import { version } from \"../generated/package\";\nimport { type CompatibilityOptions, compatibilityCheckImpl } from \"./compatibility-check\";\n\nconst defaults: CompatibilityOptions = {\n\tsilent: false,\n\tversion,\n\tlogger(text: string): void {\n\t\t/* eslint-disable-next-line no-console -- expected to log */\n\t\tconsole.error(text);\n\t},\n};\n\n/**\n * Tests if plugin is compatible with html-validate library. Unless the `silent`\n * option is used a warning is displayed on the console.\n *\n * @public\n * @since v5.0.0\n * @param name - Name of plugin\n * @param declared - What library versions the plugin support (e.g. declared peerDependencies)\n * @returns - `true` if version is compatible\n */\nexport function compatibilityCheck(\n\tname: string,\n\tdeclared: string,\n\toptions?: Partial<CompatibilityOptions>,\n): boolean {\n\treturn compatibilityCheckImpl(name, declared, {\n\t\t...defaults,\n\t\t...options,\n\t});\n}\n"],"names":[],"mappings":"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"}